diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..85bb5f4
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,5 @@
+{
+  "java.compile.nullAnalysis.mode": "automatic",
+  "java.configuration.updateBuildConfiguration": "automatic",
+  "java.debug.settings.onBuildFailureProceed": true
+}
diff --git a/pom.xml b/pom.xml
index 5b42e9a..7c269be 100644
--- a/pom.xml
+++ b/pom.xml
@@ -39,6 +39,8 @@
         <air.test.jvmsize>2g</air.test.jvmsize>
         <air.check.skip-spotbugs>true</air.check.skip-spotbugs>
         <air.check.skip-pmd>true</air.check.skip-pmd>
+        <air.check.skip-checkstyle>true</air.check.skip-checkstyle>
+        <checkstyle.skip>true</checkstyle.skip>
     </properties>
 
     <dependencies>
@@ -64,6 +66,13 @@
     <build>
         <pluginManagement>
             <plugins>
+                <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-checkstyle-plugin</artifactId>
+                    <configuration>
+                        <skip>true</skip>
+                    </configuration>
+                </plugin>
                 <plugin>
                     <groupId>com.github.spotbugs</groupId>
                     <artifactId>spotbugs-maven-plugin</artifactId>
diff --git a/src/main/java/io/trino/tpch/Runner.java b/src/main/java/io/trino/tpch/Runner.java
new file mode 100644
index 0000000..ace6440
--- /dev/null
+++ b/src/main/java/io/trino/tpch/Runner.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.trino.tpch;
+
+import java.io.File;
+
+public class Runner {
+    public static void main(String[] args) {
+        // Implements a dbgen command line utility interface to allow
+        // users to generate TPC-H data.
+        //
+        // The interface supported is :
+        // -s <scale> 1 Scale of the database population. Scale
+        // 1.0 represents ~1 GB of data
+        // -o <output directory> Directory to place the output data
+        //
+        // This isn't handled since we probably want all the data to build
+        // the CSV files used for tests.
+        //
+        // -T <table> Generate the data for a particular table
+        // ONLY. Arguments: p -- part/partuspp,
+        // c -- customer, s -- supplier,
+        // o -- orders/lineitem, n -- nation, r -- region,
+        // l -- code (same as n and r),
+        // O -- orders, L -- lineitem, P -- part,
+        // S -- partsupp
+
+        if (args.length < 2) {
+            System.out.println("Usage: <scale> <output directory>");
+            System.exit(1);
+        }
+
+        double scale = Double.parseDouble(args[0]);
+
+        // Check that the scale is within TPC-H limits.
+        if (scale < 0.01 || scale > 1000) {
+            System.out.println("Scale must be between 0.01 and 1000");
+            System.exit(1);
+        }
+
+        String outputDirectory = args[1];
+
+        // Check if the output directory exists.
+        File directory = new File(outputDirectory);
+
+        // Check if the output directory is a directory.
+        if (!directory.isDirectory()) {
+            System.out.println("Output directory does not exist or is not a directory");
+            System.exit(1);
+        }
+
+        // Check if the output directory exists.
+        if (directory.isDirectory() && !directory.exists()) {
+            System.out.println("Output directory does not exist");
+            System.exit(1);
+        }
+
+        TpchTable.toCsvFile(outputDirectory, scale);
+    }
+
+}
diff --git a/src/main/java/io/trino/tpch/TpchTable.java b/src/main/java/io/trino/tpch/TpchTable.java
index 35ccb7a..1eed611 100644
--- a/src/main/java/io/trino/tpch/TpchTable.java
+++ b/src/main/java/io/trino/tpch/TpchTable.java
@@ -13,76 +13,65 @@
  */
 package io.trino.tpch;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
+import static com.google.common.base.Preconditions.checkArgument;
 
+import java.io.FileWriter;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 import java.util.List;
 import java.util.Map;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 
-public abstract class TpchTable<E extends TpchEntity>
-{
-    public static final TpchTable<Customer> CUSTOMER = new TpchTable<Customer>("customer", CustomerColumn.values())
-    {
+public abstract class TpchTable<E extends TpchEntity> {
+    public static final TpchTable<Customer> CUSTOMER = new TpchTable<Customer>("customer", CustomerColumn.values()) {
         @Override
-        public Iterable<Customer> createGenerator(double scaleFactor, int part, int partCount)
-        {
+        public Iterable<Customer> createGenerator(double scaleFactor, int part, int partCount) {
             return new CustomerGenerator(scaleFactor, part, partCount);
         }
     };
 
-    public static final TpchTable<Order> ORDERS = new TpchTable<Order>("orders", OrderColumn.values())
-    {
+    public static final TpchTable<Order> ORDERS = new TpchTable<Order>("orders", OrderColumn.values()) {
         @Override
-        public Iterable<Order> createGenerator(double scaleFactor, int part, int partCount)
-        {
+        public Iterable<Order> createGenerator(double scaleFactor, int part, int partCount) {
             return new OrderGenerator(scaleFactor, part, partCount);
         }
     };
 
-    public static final TpchTable<LineItem> LINE_ITEM = new TpchTable<LineItem>("lineitem", LineItemColumn.values())
-    {
+    public static final TpchTable<LineItem> LINE_ITEM = new TpchTable<LineItem>("lineitem", LineItemColumn.values()) {
         @Override
-        public Iterable<LineItem> createGenerator(double scaleFactor, int part, int partCount)
-        {
+        public Iterable<LineItem> createGenerator(double scaleFactor, int part, int partCount) {
             return new LineItemGenerator(scaleFactor, part, partCount);
         }
     };
 
-    public static final TpchTable<Part> PART = new TpchTable<Part>("part", PartColumn.values())
-    {
+    public static final TpchTable<Part> PART = new TpchTable<Part>("part", PartColumn.values()) {
         @Override
-        public Iterable<Part> createGenerator(double scaleFactor, int part, int partCount)
-        {
+        public Iterable<Part> createGenerator(double scaleFactor, int part, int partCount) {
             return new PartGenerator(scaleFactor, part, partCount);
         }
     };
 
-    public static final TpchTable<PartSupplier> PART_SUPPLIER = new TpchTable<PartSupplier>("partsupp", PartSupplierColumn.values())
-    {
+    public static final TpchTable<PartSupplier> PART_SUPPLIER = new TpchTable<PartSupplier>("partsupp",
+            PartSupplierColumn.values()) {
         @Override
-        public Iterable<PartSupplier> createGenerator(double scaleFactor, int part, int partCount)
-        {
+        public Iterable<PartSupplier> createGenerator(double scaleFactor, int part, int partCount) {
             return new PartSupplierGenerator(scaleFactor, part, partCount);
         }
     };
 
-    public static final TpchTable<Supplier> SUPPLIER = new TpchTable<Supplier>("supplier", SupplierColumn.values())
-    {
+    public static final TpchTable<Supplier> SUPPLIER = new TpchTable<Supplier>("supplier", SupplierColumn.values()) {
         @Override
-        public Iterable<Supplier> createGenerator(double scaleFactor, int part, int partCount)
-        {
+        public Iterable<Supplier> createGenerator(double scaleFactor, int part, int partCount) {
             return new SupplierGenerator(scaleFactor, part, partCount);
         }
     };
 
-    public static final TpchTable<Nation> NATION = new TpchTable<Nation>("nation", NationColumn.values())
-    {
+    public static final TpchTable<Nation> NATION = new TpchTable<Nation>("nation", NationColumn.values()) {
         @Override
-        public Iterable<Nation> createGenerator(double scaleFactor, int part, int partCount)
-        {
+        public Iterable<Nation> createGenerator(double scaleFactor, int part, int partCount) {
             if (part != 1) {
                 return ImmutableList.of();
             }
@@ -90,11 +79,9 @@ public abstract class TpchTable<E extends TpchEntity>
         }
     };
 
-    public static final TpchTable<Region> REGION = new TpchTable<Region>("region", RegionColumn.values())
-    {
+    public static final TpchTable<Region> REGION = new TpchTable<Region>("region", RegionColumn.values()) {
         @Override
-        public Iterable<Region> createGenerator(double scaleFactor, int part, int partCount)
-        {
+        public Iterable<Region> createGenerator(double scaleFactor, int part, int partCount) {
             if (part != 1) {
                 return ImmutableList.of();
             }
@@ -110,13 +97,11 @@ public abstract class TpchTable<E extends TpchEntity>
         TABLES_BY_NAME = Maps.uniqueIndex(TABLES, TpchTable::getTableName);
     }
 
-    public static List<TpchTable<?>> getTables()
-    {
+    public static List<TpchTable<?>> getTables() {
         return TABLES;
     }
 
-    public static TpchTable<?> getTable(String tableName)
-    {
+    public static TpchTable<?> getTable(String tableName) {
         TpchTable<?> table = TABLES_BY_NAME.get(tableName);
         checkArgument(table != null, "Table %s not found", tableName);
         return table;
@@ -126,8 +111,7 @@ public abstract class TpchTable<E extends TpchEntity>
     private final List<TpchColumn<E>> columns;
     private final Map<String, TpchColumn<E>> columnsByName;
 
-    private TpchTable(String tableName, TpchColumn<E>[] columns)
-    {
+    private TpchTable(String tableName, TpchColumn<E>[] columns) {
         this.tableName = tableName;
         this.columns = ImmutableList.copyOf(columns);
         this.columnsByName = new ImmutableMap.Builder<String, TpchColumn<E>>()
@@ -136,22 +120,75 @@ public abstract class TpchTable<E extends TpchEntity>
                 .build();
     }
 
-    public String getTableName()
-    {
+    public String getTableName() {
         return tableName;
     }
 
-    public List<TpchColumn<E>> getColumns()
-    {
+    public List<TpchColumn<E>> getColumns() {
         return columns;
     }
 
-    public TpchColumn<E> getColumn(String columnName)
-    {
+    public TpchColumn<E> getColumn(String columnName) {
         TpchColumn<E> column = columnsByName.get(columnName);
         checkArgument(column != null, "Table %s does not have a column %s", tableName, columnName);
         return column;
     }
 
     public abstract Iterable<E> createGenerator(double scaleFactor, int part, int partCount);
+
+    @Override
+    public String toString() {
+        return tableName;
+    }
+
+    public static void toCsvFile(String outputDirectory, Double scale) {
+        // Create a table of generators (iterables) for each table.
+        List<TpchTable<?>> tables = TpchTable.getTables();
+
+        // Iterate and write a CSV file for each table in the target directory.
+        for (TpchTable<?> table : tables) {
+            String tableName = table.getTableName();
+            List<? extends TpchColumn<?>> columns = table.getColumns();
+            String fileName = outputDirectory + "/" + tableName + ".csv";
+
+            var generator = table.createGenerator(scale, 1, 1);
+            FileWriter writer;
+            try {
+                writer = new FileWriter(fileName, StandardCharsets.UTF_8);
+                for (var entity : generator) {
+                    // Write the entity to the CSV file, entity is a row of objects and each
+                    // object is indexed into its columns by the table's columns to properly
+                    // cast the object to the correct type.
+
+                    // Cast and build the row of objects.
+                    var line = entity.toLine();
+
+                    // Write the line to the CSV file.
+                    // Write the CSV file.
+                    try {
+
+                        // Write the header.
+                        String[] header = columns.stream().map((TpchColumn<?> column) -> column.getColumnName())
+                                .toArray(String[]::new);
+
+                        writer.write(String.join(",", header));
+
+                        // Write the line.
+                        writer.write(line);
+
+                        // Close the writer.
+                        writer.close();
+                    } catch (IOException e) {
+                        System.out.println("Error writing CSV file: " + e.getMessage());
+                        System.exit(1);
+                    }
+
+                }
+            } catch (IOException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            }
+        }
+    }
+
 }
diff --git a/src/main/java/io/trino/tpch/TpchTables.java b/src/main/java/io/trino/tpch/TpchTables.java
new file mode 100644
index 0000000..8017fcd
--- /dev/null
+++ b/src/main/java/io/trino/tpch/TpchTables.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.trino.tpch;
+
+// Enumerates the tables that can be generated by the dbgen utility.
+//
+// The tables are:
+// - Part
+// - PartSupp
+// - Supplier
+// - Customer
+// - Orders
+// - LineItem
+// - Nation
+// - Region
+public enum TpchTables {
+    PART,
+    PARTSUPP,
+    SUPPLIER,
+    CUSTOMER,
+    ORDERS,
+    LINEITEM,
+    NATION,
+    REGION
+}
diff --git a/src/test/java/io/trino/tpch/TestNationGenerator.java b/src/test/java/io/trino/tpch/TestNationGenerator.java
index c3212f7..4e0f432 100644
--- a/src/test/java/io/trino/tpch/TestNationGenerator.java
+++ b/src/test/java/io/trino/tpch/TestNationGenerator.java
@@ -13,16 +13,119 @@
  */
 package io.trino.tpch;
 
-import org.testng.annotations.Test;
-
 import static io.trino.tpch.GeneratorAssertions.assertEntityLinesMD5;
 
-public class TestNationGenerator
-{
+import org.testng.annotations.Test;
+
+public class TestNationGenerator {
     @SuppressWarnings("SpellCheckingInspection")
     @Test
-    public void testGenerator()
-    {
+    public void testGenerator() {
         assertEntityLinesMD5(new NationGenerator(), "2f588e0b7fa72939b498c2abecd9fbbe");
     }
+
+    @Test
+    public void testNationsGenerator() {
+        var nationsGenerator = new NationGenerator();
+
+        for (var nation : nationsGenerator) {
+            System.out.println(nation);
+        }
+    }
+
+    @Test
+    public void testRegionsGenerator() {
+        var regionsGenerator = new RegionGenerator();
+
+        for (var region : regionsGenerator) {
+            System.out.println(region);
+        }
+    }
+
+    @Test
+    public void testPartGenerator() {
+        var partGenerator = new PartGenerator(0.01, 1, 1);
+
+        for (var part : partGenerator) {
+            System.out.println(part);
+        }
+    }
+
+    @Test
+    public void testDistributionLoader() {
+        var distributions = Distributions.getDefaultDistributions();
+
+        // Show p_types and p_cntr distributions.
+        var pTypes = distributions.getPartTypes();
+        var pCntr = distributions.getPartContainers();
+
+        for (int i = 0; i < pTypes.size(); i++) {
+            var value = pTypes.getValue(i);
+            var weight = pTypes.getWeight(i);
+            System.out.println(value + " " + weight);
+        }
+
+        for (int i = 0; i < pCntr.size(); i++) {
+            var value = pCntr.getValue(i);
+            var weight = pCntr.getWeight(i);
+            System.out.println(value + " " + weight);
+        }
+    }
+
+    @Test
+    public void TestSupplierGenerator() {
+        var supplierGenerator = new SupplierGenerator(0.01, 1, 1);
+
+        for (var supplier : supplierGenerator) {
+            System.out.println(supplier);
+        }
+    }
+
+    @Test
+    void testCustomerGenerator() {
+        var customerGenerator = new CustomerGenerator(0.01, 1, 1);
+
+        for (var customer : customerGenerator) {
+            System.out.println(customer);
+        }
+    }
+
+    @Test
+    void testPartSupplierGenerator() {
+        var partSupplierGenerator = new PartSupplierGenerator(0.01, 1, 1);
+
+        for (var partSupplier : partSupplierGenerator) {
+            System.out.println(partSupplier);
+        }
+    }
+
+    @Test
+    void testOrderGenerator() {
+        var orderGenerator = new OrderGenerator(0.01, 1, 1);
+        var count = 0;
+
+        for (var order : orderGenerator) {
+            System.out.println(order);
+            count++;
+            if (count > 10) {
+                break;
+            }
+        }
+    }
+
+    @Test
+    void testLineItemGenerator() {
+        var lineItemGenerator = new LineItemGenerator(0.01, 1, 1);
+
+        var count = 0;
+
+        for (var lineItem : lineItemGenerator) {
+            System.out.println(lineItem);
+            count++;
+            if (count > 10) {
+                break;
+            }
+        }
+    }
+
 }
